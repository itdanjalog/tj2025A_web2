
1. 변수와 상수
    const : 상수, 재할당 불가
    let : 블록 스코프 변수, 중복 선언 불가
    var : 함수 스코프, 중복 선언 가능 (옛날 방식)

2. 함수
선언식 : function fun1(param1, param2) {}
표현식 : const fun2 = function(param1, param2) {}
화살표 함수 : const fun3 = (param1, param2) => {}
기본값 파라미터 : const fun4 = (param1, param2 = '학생') => {}
나머지 파라미터 : const fun5 = (param1, ...params) => {}

3. 객체
{ key: value }
속성명 단축 : { value }
접근 : obj.key








// ===================================================================================

[1] 변수 와 상수
    const 키워드
    let 키워드
    * var 키워드 : let 나오기전에 사용했던 변수 선언 키워드 , 변수들간의 변수명 중복이 가능하다.

[2] 함수
    1. 정의
    function fun1( param1 , param2 ){ }
    const fun2 = function ( param1 , param2 ){ }
    const fun3 = ( param1 , param2 ) => { }
    const fun4 = ( param1 , param2 , param3 = '학생') => { }
    const fun5 = ( param1 , ...params ) => { }
    const fun6 = ( param1 , param2 = '학생' , ...params ) => { }
    2. 호출
        - 함수명( 인자값 , 인자값 )

[3] 객체
    1. { } 객체 : key(속성명) 와 value(속성값) 으로 한쌍을 구성하여 여러쌍을 { } 묶음
    { key : value , key : value , key : value , key : value }

    2. 속성명(key) 단축 : value 의 변수명이 속성명과 동일하게 선언할떄
    { value , value , value , value }

    3. 속성값 호출 : .(접근연산자) 이용한 객체내 속성값 호출
    .속성명

[4] 리스트
    1. [ ] 리스트 : [ value , value , value , value , value ]
    2. 리스트 내 값 호출
    [인덱스]

[5] 스프레드 연산자(...)
    1.기존배열과 새로운 값으로 새로운 배열 선언
    const newArr = [ ...arr1 , value , value ]
    2.기존객체와 새로운 속성으로 새로운 객체 선언
    const newObj = { ...obj1 , key : value }

[6] 구조/비구조 분해 할당 : 배열또는 객체를 분해 해서 각 변수에 저장
    1. const { key1 , key2 }  = { key1 : value1 , key2 : value2 }
    2. const { key1 , ...keys } = { key1 : value1 , key2 : value2 , key3 : value3 }
    2. const [ value1 , ...value2 ] = [ value1 , value2 , value3 ]

[7] 나머지 연산자(...) : 마지막에 위치에 정의 해야한다.
    1. 매개변수를 한번에 받을때 : ( param1 , ...param2 )
    2. 구조 분해 할당

[8] 백틱 : 백틱 : 문자열 템플릿 , +연산자 가 아닌 `(백틱) 안에 ${}를 이용하여 문자열과 표현식을 연결할 때 사용.
// 백틱 `${ 선언부 불가능 / 표현부 가능 }` ,
    // 선언부 : if/for/while/객체/변수/함수 선언 등등 불가능,
    // 표현부 : 1 + 3 /  삼항연산자 / 변수호출/함수호출/객체호출 등등 가능

[9] 삼항연산자 , 조건 ? 참 : 거짓

[10] 단축 평가(연산)
1. 조건(A) && 참(B) : 만약에 조건이 true 이면 B 반환 false 이면 A 반환
2. 조건(A) || 거짓(B) : 만약에 조건이 true 이면 A반환 false 이면 B 반환



[12] for문
1. 일반 for문  : for( let 반복변수명 = 0 ; 반복변수명<=배열명.length-1 ; 반복변수명-1 ){ }
2. 향상된 for문 :
    1. for( let 반복변수명 in 배열명 ){ }
    2. for( let 반복변수명 of 배열명 ){ }
3. forEach vs map vs filter
    1. 배열명.forEach( ( 반복변수명 , 인덱스변수명 )=> {} )
    2. const 반환된배열명 = 배열명.map( ( 반복변수명 , 인덱스변수명 )=> { return } )
    3. const 조건반환배열명 =  배열명.filter( ( 반복변수명 , 인덱스변수명 )=> { return 조건식 } )


    [ JS ]
        (1) for( 초기값 ; 조건문 ; 증감식 ){ }
        (2) for( 타입 반복변수 in 리스트/배열 ) { }
        (2) for( 타입 반복변수 of 리스트/배열 ) { }
        (3) 리스트.forEach( (반복변수) => {} );
        (4) 리스트.map( (반복변수) => {} );
        (5) 리스트.filter( (반복변수) => {} );

        * forEach 함수는 반환을 제공하지 않는다.
        * map 에서 구현코드가 한줄이면 return 생략
            -> map 형식은 리액트 jsx 에서 많이 사용된다.

📘 [모듈] JavaScript Module
[1] 모듈 정의

모듈(Module): 프로그램을 여러 개의 독립적인 파일로 나누어 관리하는 방식

JS에서 하나의 파일이 하나의 모듈이 된다.

모듈은 export로 외부에 기능을 공개하고, import로 불러와서 사용한다.


[2] export

모듈 안에서 변수, 함수, 클래스 등을 외부로 내보낼 때 사용

[3] import

다른 모듈에서 export한 기능을 불러올 때 사용

[4] HTML에서 모듈 사용

브라우저에서 모듈을 사용하려면 반드시 <script type="module"> 을 써야 한다.

이유: 브라우저가 import/export 구문을 이해하도록 알려주기 위해서